package com.roc.cloud.canary.gateway.starter.balancer;import cn.hutool.core.collection.CollectionUtil;import cn.hutool.extra.spring.SpringUtil;import com.roc.cloud.common.constant.CommonConstant;import com.roc.cloud.common.constant.HeaderConstant;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.ObjectProvider;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.loadbalancer.reactive.DefaultResponse;import org.springframework.cloud.client.loadbalancer.reactive.EmptyResponse;import org.springframework.cloud.client.loadbalancer.reactive.Request;import org.springframework.cloud.client.loadbalancer.reactive.Response;import org.springframework.cloud.loadbalancer.core.NoopServiceInstanceListSupplier;import org.springframework.cloud.loadbalancer.core.ReactorServiceInstanceLoadBalancer;import org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;import org.springframework.http.HttpHeaders;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Random;import java.util.concurrent.atomic.AtomicInteger;import java.util.stream.Collectors;/** * 负载均衡策略 * * @author Roc * @version 1.0, 2020/5/5 15:34 */@Slf4jpublic class CanaryLoadBalancer implements ReactorServiceInstanceLoadBalancer {    private ObjectProvider<ServiceInstanceListSupplier> serviceInstanceListSupplierProvider;    private String serviceId;    private final AtomicInteger position;    /**     * 负载均衡策略-构造函数入口     *     * @param serviceInstanceListSupplierProvider :     * @param serviceId                           :     * @return     * @author Roc     * @date 2020/9/30     **/    public CanaryLoadBalancer(ObjectProvider<ServiceInstanceListSupplier> serviceInstanceListSupplierProvider,                              String serviceId) {        this.serviceId = serviceId;        this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider;        this.position = new AtomicInteger(new Random().nextInt(1000));    }    /**     * Choose the next server based on the load balancing algorithm.     *     * @param request - an input request     * @return - mono of response     */    @Override    public Mono<Response<ServiceInstance>> choose(Request request) {        HttpHeaders headers = (HttpHeaders) request.getContext();        if (this.serviceInstanceListSupplierProvider != null) {            ServiceInstanceListSupplier supplier = this.serviceInstanceListSupplierProvider                    .getIfAvailable(NoopServiceInstanceListSupplier::new);            return ((Flux) supplier.get()).next().map(list -> getInstanceResponse((List<ServiceInstance>) list, headers));        }        return null;    }    private Response<ServiceInstance> getInstanceResponse(List<ServiceInstance> instances, HttpHeaders headers) {        if (instances.isEmpty()) {            return getServiceInstanceEmptyResponse();        } else {            return getServiceInstanceResponseByVersion(instances, headers);        }    }    /**     * 根据版本进行分发     *     * @param instances     * @param headers     * @return     */    private Response<ServiceInstance> getServiceInstanceResponseByVersion(List<ServiceInstance> instances,                                                                          HttpHeaders headers) {        // 从Header中获取版本号        String versionNo = headers.getFirst(HeaderConstant.CANARY_VERSION_HEADER);        //能使用的instance        List<ServiceInstance> canUseInstance = new ArrayList<>();        if (StringUtils.isNotEmpty(versionNo)) {            // 依据版本号做请求分发            log.debug("灰度版本号: " + versionNo);            List<ServiceInstance> currentVersionInstances = instances                    .stream()                    .filter(serviceInstance -> {                        // 迭代所有服务版本号                        final Map<String, String> metadata = serviceInstance.getMetadata();                        // nacos 元数据中的version                        String version = metadata.get(HeaderConstant.CANARY_VERSION_HEADER);                        log.debug("当前服务版本号: " + version);                        return versionNo.equals(version);                    }).collect(Collectors.toList());            // 优先选择客户IP对应实例实例            String requestIp = headers.getFirst(HeaderConstant.CANARY_REQUESTIP_HEADER);            String activeProfile = SpringUtil.getApplicationContext().getEnvironment().getActiveProfiles()[0];            if (CommonConstant.PROFILES.contains(activeProfile) && StringUtils.isNotBlank(requestIp)) {                List<ServiceInstance> ipServiceInstance = currentVersionInstances.stream().filter(serviceInstance -> requestIp.equals(serviceInstance.getHost())).collect(Collectors.toList());                if (CollectionUtil.isNotEmpty(ipServiceInstance)) {                    currentVersionInstances = ipServiceInstance;                } else {                    // 开发环境，灰度服务按照IP无法精确匹配时，如果其他IP不匹配的相同版本灰度服务也不存在，那么从非灰度服务中选择                    // 这个改动是为了解决下面的问题：多人本地机器同时进行调试时，如果都配置了相同灰度版本标识，请求可能会路由到其他人的机器，影响开发效率                    if (CollectionUtil.isEmpty(currentVersionInstances)) {                        log.warn("未找到相同版本的灰度服务目标实例, 从非灰度服务中查询。profiles = {}, versionNo = {}, requestIp = {}", activeProfile, versionNo, requestIp);                        currentVersionInstances = instances                                .stream()                                .filter((instance -> StringUtils.isBlank(instance.getMetadata().get(HeaderConstant.CANARY_VERSION_HEADER))))                                .collect(Collectors.toList());                    }                }            }            if (CollectionUtil.isNotEmpty(currentVersionInstances)) {                canUseInstance.addAll(currentVersionInstances);            } else {                canUseInstance.addAll(instances);            }            return getInstanceResponse(canUseInstance);        }        // 过滤灰度可用服务实例        canUseInstance = instances.stream()                .filter((instance) -> StringUtils.isBlank(instance.getMetadata().get(HeaderConstant.CANARY_VERSION_HEADER)))                .collect(Collectors.toList());        return getInstanceResponse(canUseInstance);        // 如果服务为空返回空//        if (CollectionUtils.isEmpty(canUseInstance)) {//            // 未找到对应的版本号，走默认的服务轮询//            return getInstanceResponse(instances);//            ///return getServiceInstanceEmptyResponse();//        }        // 可用服务做负载均衡,轮询、权重等        /// canUseInstance.forEach(canInstance -> {        ///     final Map<String, String> metadata = canInstance.getMetadata();        //     // nacos上的权重        ///     String weight = metadata.get("weight");        ///     log.info("ServiceId: " + canInstance.getServiceId() + " Weight: " + weight);        //     // 先随机取一个        /// });        // 先走默认轮询//        return getInstanceResponse(canUseInstance);    }    private Response<ServiceInstance> getServiceInstanceEmptyResponse() {        log.warn("getServiceInstanceEmptyResponse ----> No servers available for service: " + this.serviceId);        return new EmptyResponse();    }    private Response<ServiceInstance> getInstanceResponse(            List<ServiceInstance> instances) {        if (instances.isEmpty()) {            log.warn("getInstanceResponse---> No servers available for service: " + this.serviceId);            return new EmptyResponse();        }        // TODO: enforce order?        int pos = Math.abs(this.position.incrementAndGet());        ServiceInstance instance = instances.get(pos % instances.size());        return new DefaultResponse(instance);    }}