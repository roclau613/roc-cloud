package com.roc.cloud.db.datasource;import com.roc.cloud.db.entity.TenantDataSourceInfo;import com.roc.cloud.db.tenant.TenantContextHandler;import java.sql.SQLException;import java.util.Map;import javax.sql.DataSource;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;/** * @ClassName: AbstractDynamicDataSource * @Description: 动态数据源父类 * @author: Roc * @date: 2020/9/24 9:37 **/@Slf4jpublic abstract class AbstractDynamicDataSource<T extends DataSource> extends AbstractRoutingDataSource        implements ApplicationContextAware {    /** 默认的数据源KEY，和spring配置文件中的id=druidDynamicDataSource的bean中配置的默认数据源key保持一致 */    public static final String DEFAULT_DATASOURCE_KEY = "defaultDataSource";    /** 数据源KEY-VALUE键值对 */    public Map<Object, Object> targetDataSources;    /** spring容器上下文 */    private static ApplicationContext ctx;    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        ctx = applicationContext;    }    public static ApplicationContext getApplicationContext() {        return ctx;    }    public static Object getBean(String name) {        return ctx.getBean(name);    }    /**     * @param targetDataSources the targetDataSources to set     */    @Override    public void setTargetDataSources(Map<Object, Object> targetDataSources) {        this.targetDataSources = targetDataSources;        super.setTargetDataSources(targetDataSources);        // afterPropertiesSet()方法调用时用来将targetDataSources的属性写入resolvedDataSources中的        super.afterPropertiesSet();    }    /**     * 创建数据源     *     * @param driverClassName : 数据库驱动名称     * @param url : 连接地址     * @param username : 用户名     * @param password : 密码     * @return javax.sql.DataSource     * @throws SQLException     * @author Roc     * @date 2020/9/30     **/    public abstract DataSource createDataSource(String driverClassName, String url, String username, String password)            throws SQLException;    /**     * 租户数据源信息     *     * @param tenantDataSourceInfo :     * @return javax.sql.DataSource     * @throws SQLException     * @author Roc     * @date 2020/9/30     **/    protected abstract DataSource createDataSource(TenantDataSourceInfo tenantDataSourceInfo)            throws SQLException;    /**     * 设置系统当前使用的数据源     * 数据源为空或者为0时，自动切换至默认数据源，即在配置文件中定义的默认数据源     *     * @return java.lang.Object     * @author Roc     * @date 2020/9/30     **/    @Override    protected Object determineCurrentLookupKey() {        TenantDataSourceInfo tenantDataSourceInfo = DbContextHolder.getDbType();        if (null == tenantDataSourceInfo) {            log.debug("==========未设置数据源，使用系统默认数据源");            // 使用默认数据源            return DEFAULT_DATASOURCE_KEY;        }        // 判断数据源是否需要初始化        try {            this.verifyAndInitDataSource(tenantDataSourceInfo);        } catch (SQLException e) {            log.error("verifyAndInitDataSource fail: ", e);        }        return tenantDataSourceInfo.getTenant();    }    /**     * 判断数据源是否需要初始化     *     * @param tenantDataSourceInfo :     * @return void     * @author Roc     * @date 2020/9/30     **/    private void verifyAndInitDataSource(TenantDataSourceInfo tenantDataSourceInfo) throws SQLException {        // 数据源已初始化        Object obj = this.targetDataSources.get(tenantDataSourceInfo.getTenant());        if (obj != null) {            // 已找到数据源            return;        }        log.debug("==========数据源未初始化，开始初始化租户：[{}]的数据源", TenantContextHandler.getTenant());        DataSource dataSource = this.createDataSource(tenantDataSourceInfo);        this.addTargetDataSource(tenantDataSourceInfo.getTenant(), dataSource);    }    /**     * 往数据源key-value键值对集合添加新的数据源     *     * @param key 新的数据源键     * @param dataSource 新的数据源     */    protected void addTargetDataSource(String key, DataSource dataSource) {        log.debug("==========添加当前租户：[{}]的数据源到容器", key);        this.targetDataSources.put(key, dataSource);        super.setTargetDataSources(this.targetDataSources);        super.afterPropertiesSet();    }}