package com.roc.cloud.security.auth.service.impl;import cn.hutool.core.date.DateUtil;import cn.hutool.json.JSONUtil;import com.alibaba.fastjson.JSON;import com.nimbusds.jose.JOSEException;import com.nimbusds.jose.JOSEObjectType;import com.nimbusds.jose.JWSAlgorithm;import com.nimbusds.jose.JWSHeader;import com.nimbusds.jose.JWSObject;import com.nimbusds.jose.JWSSigner;import com.nimbusds.jose.JWSVerifier;import com.nimbusds.jose.Payload;import com.nimbusds.jose.crypto.MACSigner;import com.nimbusds.jose.crypto.MACVerifier;import com.nimbusds.jose.crypto.RSASSASigner;import com.nimbusds.jose.crypto.RSASSAVerifier;import com.nimbusds.jose.jwk.RSAKey;import com.roc.cloudsecurity.auth.api.PayloadDto;import com.roc.cloud.security.auth.exception.JwtExpiredException;import com.roc.cloud.security.auth.exception.JwtInvalidException;import com.roc.cloud.security.auth.service.JwtTokenService;import java.security.KeyPair;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.text.ParseException;import java.util.Date;import java.util.UUID;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.core.io.ClassPathResource;import org.springframework.security.rsa.crypto.KeyStoreKeyFactory;/** * JWT-token管理 <br> * * @date: 2020/10/16 <br> * @author: Roc <br> * @since: 1.0 <br> * @version: 1.0 <br> */@ConditionalOnProperty(prefix = "roc.cloud.security.jwt", name = "enabled", havingValue = "true")public class JwtTokenServiceImpl implements JwtTokenService {    private static final String JKS_SUFFIX = ".jks";    private static final String DEFAULT_SECRET = "0123456789sdsdasdqwdqwdasdasdqwwdZwdawd";    @Value("${roc.cloud.security.jwt.sub:roc-cloud}")    private String sub;    @Value("${roc.cloud.security.jwt.alias:jwt}")    private String alias;    @Value("${roc.cloud.security.jwt.password:123456}")    private String password;    @Value("${roc.cloud.security.jwt.expired:30}")    private int expired;    /**     * 默认方法，测试用，后续根据需求会做调整，正式环境不要用     *     * @return     * @author Roc     * @date 2020/10/16     **/    @Override    public PayloadDto getDefaultPayloadDto() {        return getDefaultPayloadDto(expired);    }    /**     * 获取payload，指定过期时间     *     * @param expired 过期时间（分钟）     * @return     * @author zj     * @date 2021/01/06     **/    @Deprecated    @Override    public PayloadDto getDefaultPayloadDto(int expired) {        Date now = new Date();        Date exp = DateUtil.offsetSecond(now, expired * 60);        return PayloadDto.builder()                .sub(sub)                .iat(now.getTime())                .exp(exp.getTime())                .jti(UUID.randomUUID().toString())                .build();    }    /**     * 使用HMAC算法生成token     *     * @param payloadStr :     * @param secret     :     * @return java.lang.String     * @throws JOSEException     * @author Roc     * @date 2020/10/16     **/    @Override    public String generateTokenByHmac(String payloadStr, String secret) throws JOSEException {        secret = StringUtils.isBlank(secret) ? DEFAULT_SECRET : secret;        JWSHeader jwsHeader = new JWSHeader.Builder(JWSAlgorithm.HS256).                type(JOSEObjectType.JWT)                .build();        Payload payload = new Payload(payloadStr);        JWSObject jwsObject = new JWSObject(jwsHeader, payload);        JWSSigner jwsSigner = new MACSigner(secret);        jwsObject.sign(jwsSigner);        return jwsObject.serialize();    }    /**     * 使用HMAC算法校验token     *     * @param token  :     * @param secret :     * @return     * @throws ParseException     * @throws JOSEException     * @author Roc     * @date 2020/10/16     **/    @Override    public PayloadDto verifyTokenByHmac(String token, String secret) throws ParseException, JOSEException {        secret = StringUtils.isBlank(secret) ? DEFAULT_SECRET : secret;        JWSObject jwsObject = JWSObject.parse(token);        JWSVerifier jwsVerifier = new MACVerifier(secret);        if (!jwsObject.verify(jwsVerifier)) {            throw new JwtInvalidException("token signature is illegal.");        }        String payload = jwsObject.getPayload().toString();        PayloadDto payloadDto = JSONUtil.toBean(payload, PayloadDto.class);        if (payloadDto.getExp() < System.currentTimeMillis()) {            throw new JwtExpiredException("token has expired.");        }        return payloadDto;    }    /**     * 获取默认的RSAKey     *     * @return java.security.interfaces.RSAKey     * @author Roc     * @date 2020/10/16     **/    @Override    public RSAKey getDefaultRsaKey() {        KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(new ClassPathResource(alias + JKS_SUFFIX),                password.toCharArray());        KeyPair keyPair = keyStoreKeyFactory.getKeyPair(alias, password.toCharArray());        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();        return new RSAKey.Builder(publicKey).privateKey(privateKey).build();    }    /**     * 使用RSA算法生成token     *     * @param payloadStr :     * @param rsaKey     :     * @return java.lang.String     * @throws JOSEException     * @author Roc     * @date 2020/10/16     **/    @Override    public String generateTokenByRsa(String payloadStr, RSAKey rsaKey) throws JOSEException {        JWSHeader jwsHeader = new JWSHeader.Builder(JWSAlgorithm.RS256)                .type(JOSEObjectType.JWT)                .build();        Payload payload = new Payload(payloadStr);        JWSObject jwsObject = new JWSObject(jwsHeader, payload);        JWSSigner jwsSigner = new RSASSASigner(rsaKey, true);        jwsObject.sign(jwsSigner);        return jwsObject.serialize();    }    /**     * 使用RSA算法校验token     *     * @param token  :     * @param rsaKey :     * @return     * @throws ParseException     * @throws JOSEException     * @author Roc     * @date 2020/10/16     **/    @Override    public PayloadDto verifyTokenByRsa(String token, RSAKey rsaKey) throws ParseException, JOSEException {        JWSObject jwsObject = JWSObject.parse(token);        RSAKey publicRsaKey = rsaKey.toPublicJWK();        JWSVerifier jwsVerifier = new RSASSAVerifier(publicRsaKey);        if (!jwsObject.verify(jwsVerifier)) {            throw new JwtInvalidException("token signature is illegal.");        }        String payload = jwsObject.getPayload().toString();        PayloadDto payloadDto = JSONUtil.toBean(payload, PayloadDto.class);        if (payloadDto.getExp() < System.currentTimeMillis()) {            throw new JwtExpiredException("token has expired.");        }        return payloadDto;    }    public static void main(String[] args) throws ParseException, JOSEException {        String token = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2MDQ5MTYxMzgzNjYsImlhdCI6MTYwNDkxNDMzODM2NiwianRpIjoiM2JmOGI5Y2EtZWViYS00NjlhLTkxNzktYTFjN2I0ZjlkZDY2IiwibG9naW5Vc2VyIjp7ImNvbXBhbnlJZCI6MCwiaWQiOjgzMTA2LCJ0eXBlIjoiUEFSRU5UIn0sInN1YiI6InhpYW9nai14MyJ9.ZaM_If6_y16Py_lp0BMdVhE89ZDOt7IdPZIgqjzAFjQ";        JwtTokenServiceImpl jwtTokenService = new JwtTokenServiceImpl();        System.out.println(jwtTokenService.verifyTokenByHmac(token, DEFAULT_SECRET));        PayloadDto payloadDto = jwtTokenService.verifyTokenByHmac(token, null);        System.out.println(JSON.toJSONString(payloadDto));    }}